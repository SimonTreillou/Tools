#%%
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit


# ----------------------------------------------------
# 1) Input data
# ----------------------------------------------------
x_offshore_extent = 50  # m
x_onshore_extent  = 20  # m
S = 0.03                     # small beach slope (adjustable)
x = np.array([-193.63905325443787, -189.3491124260355, -185.6508875739645,
              -185.6508875739645, -182.10059171597635, -179.28994082840237,
              -179.28994082840237, -175.44378698224853, -169.23076923076923,
              -169.23076923076923, -162.57396449704143, -156.36094674556213,
              -152.95857988165682, -147.04142011834318, -147.04142011834318,
              -141.8639053254438, -137.1301775147929, -131.80473372781066,
              -127.51479289940829, -122.92899408284023, -118.19526627218934,
              -112.42603550295857, -105.9171597633136, -105.9171597633136,
              -99.85207100591717, -99.85207100591717, -93.49112426035504,
              -93.49112426035504, -88.75739644970415, -88.75739644970415,
              -82.24852071005917, -82.24852071005917, -75.88757396449704,
              -75.88757396449704, -68.93491124260355, -68.93491124260355,
              -63.75739644970413, -63.75739644970413, -56.508875739644964,
              -49.40828402366863, -49.40828402366863, -44.822485207100584,
              -44.822485207100584, -39.053254437869825, -39.053254437869825,
              -34.023668639053255, -34.023668639053255, -28.994082840236686,
              -28.994082840236686, -23.81656804733727, -23.81656804733727,
              -18.491124260355036, -18.491124260355036, -14.05325443786981,
              -14.05325443786981, -10.059171597633139, -10.059171597633139,
              -5.621301775147913, -5.621301775147913, -0.4437869822485254,
              -0.4437869822485254, 4.73372781065089, 4.73372781065089,
              9.615384615384613, 9.615384615384613])

y = np.array([-5.822222222222222, -5.655555555555556, -5.533333333333333,
              -5.533333333333333, -5.444444444444445, -5.333333333333334,
              -5.333333333333334, -5.188888888888889, -4.988888888888889,
              -4.988888888888889, -4.766666666666667, -4.511111111111111,
              -4.366666666666667, -4.122222222222222, -4.122222222222222,
              -3.911111111111111, -3.7333333333333334, -3.511111111111111,
              -3.333333333333333, -3.1333333333333333, -2.9, -2.6666666666666665,
              -2.422222222222222, -2.422222222222222, -2.2, -2.2, -2, -2,
              -1.811111111111111, -1.811111111111111, -1.6444444444444444,
              -1.6444444444444444, -1.5555555555555554, -1.5555555555555554,
              -1.422222222222222, -1.422222222222222, -1.3666666666666667,
              -1.3666666666666667, -1.2333333333333334, -1.1777777777777776,
              -1.1777777777777776, -1.1666666666666665, -1.1666666666666665,
              -1.1888888888888887, -1.1888888888888887, -1.2666666666666666,
              -1.2666666666666666, -1.322222222222222, -1.322222222222222,
              -1.2777777777777777, -1.2777777777777777, -1.1777777777777776,
              -1.1777777777777776, -0.9666666666666663, -0.9666666666666663,
              -0.7777777777777777, -0.7777777777777777, -0.6111111111111112,
              -0.6111111111111112, -0.45555555555555527, -0.45555555555555527,
              -0.3666666666666667, -0.3666666666666667, -0.32222222222222197,
              -0.32222222222222197])


x = np.array(x, dtype=float)
y = np.array(y, dtype=float)

# ----------------------------------------------------
# 2) Fourier-like model for the middle region
# ----------------------------------------------------
# We choose N harmonics
N = 7   # increase to 7â€“10 for even better fit

def bathy_model(x, *a):
    """Fourier-like series model for bathymetry fitting"""
    h = np.zeros_like(x)
    for n in range(1, N+1):
        An = a[2*(n-1)]
        phin = a[2*(n-1) + 1]
        kn = n * (2 * np.pi / (x.max() - x.min()))
        h += An * np.sin(kn * x + phin)
    return h

# Frequency chosen from total domain length
Lx = x.max() - x.min()
omega = 2*np.pi / Lx

def bathy_sin7(x):
    return -(
        7.006 * np.sin(0.01136 * x + 0.392) +
        3.2   * np.sin(0.02081 * x - 1.951) +
        0.4989 * np.sin(0.0376  * x - 2.404) +
        0.0404 * np.sin(0.09858 * x - 4.119) +
        0.06505 * np.sin(0.1218 * x + 1.736) +
        0.05794 * np.sin(0.1516 * x + 2.31) +
        0.04048 * np.sin(0.1783 * x + 2.487)
    )

# ----------------------------------------------------
# 4) Define the extended bathymetry with flat + slope
# ----------------------------------------------------
x_offshore = x.min() - x_offshore_extent     # extend 50 m to the left
x_onshore  = x.max() + x_onshore_extent     # extend 20 m to the right

h_inf = y.min()          # choose offshore depth slightly deeper

def full_bathy(xx):
    """
    Piecewise bathymetry:
    deep constant offshore
    Fourier fit in the measured region
    linear beach slope onshore
    """
    h = np.zeros_like(xx)
    
    # Offshore region
    idx1 = xx < x.min()
    h[idx1] = -h_inf

    # Central measured region
    idx2 = (xx >= x.min()) & (xx <= x.max())
    h[idx2] = bathy_sin7(xx[idx2])

    # Onshore beach
    idx3 = xx > x.max()
    h[idx3] = bathy_sin7(np.array([x.max()]))[0] \
              - S*(xx[idx3] - x.max())

    return h

# ----------------------------------------------------
# 5) Plot
# ----------------------------------------------------
xx = np.linspace(x_offshore, x_onshore, 1200)
hh = full_bathy(xx)

plt.figure(figsize=(10,5))
plt.plot(x, y, "ko", label="observed")
plt.plot(xx, hh, "r-", label="fit + extensions", linewidth=2)
plt.grid()
plt.xlabel("x (m)")
plt.ylabel("depth h (m)")
plt.legend()
plt.title("Extended Bathymetry Fit (Fourier + beach + offshore)")
plt.show()

# %%
